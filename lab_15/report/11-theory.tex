\chapter{Теоретическая часть}

В этом разделе приведены ответы на контрольные вопросы.

\section{В каком фрагменте программы сформулировано знание? Это знание о чем на формальном уровне?}
Знание формируется в заголовке правила (правила описываются в разделе \textbf{clauses}), может быть описано набором фактов и правил, формирующих процедуру.

Знание о предметной области.

\section{Что содержит тело правила?}
Тело правила содержит условия истинности знания, содержащегося в заголовке этого правила. Тело состоит из термов.

\section{Что дает использование переменных при формулировании знаний? В чем отличие формулировки знания с помощью термов с одинаковой арностью при использовании одной переменной и при использовании нескольких переменных?}
Использование переменных дает возможность передачи знаний о предметной области. Например, связанная с каким-то значением переменная, в рамках одного предложения, может быть использована в последующих подцелях тела правила

Чем больше переменных используется в определение терма, тем более общим будет являться терм. Например, car(petrov, ford, pink, Price) является примером терма car(Lastname, ford, pink, Price), т.е car(Lastname, ford, pink, Price) является более общим.

\section{С каким квантором переменные входят в правило, в каких пределах переменная уникальна?}
На все переменные в имени предиката наложен квантор всеобщности; на переменные в теле предиката, которые отсутствуют в имени, наложен квантор существования.

Именованная переменная уникальна в рамках предложения, в котором она используются. Любая анонимная переменная является уникальной.

\section{Какова семантика (смысл) предложений раздела DOMAINS\@? Когда, где и с какой целью используется это описание?}
Раздел описания доменов является аналогом раздела описания типов в императивных языках программирования. Домены должны быть определены до их использования. Например: lastname=symbol.

Из доменов можно конструировать составные или структурные домены (структуры). Структура описывается следующим образом:

<имя структуры>=<имя функтора>(<имя домена первой компоненты>, \ldots, <имя домена последней компоненты>).

\sloppy\section{Какова семантика (смысл) предложений раздела PREDICATES\@? Когда, и где используется это описание? С какой целью?}
В разделе, озаглавленном зарезервированным словом \textbf{predicates}, содержатся описания определяемых пользователем предикатов. В императивных языках программирования подобными разделами являются разделы описания заголовков процедур и функций. Предикаты должны быть определены до их использования. Описание n-местного предиката имеет следующий вид:

<имя предиката>(<имя домена первого аргумента>, \ldots{}, <имя домена n-го аргумента>).

Домены аргументов должны быть либо стандартными, либо объявленными в разделе описания доменов. Один предикат может иметь несколько описаний

\section{Унификация каких термов запускается на самом первом шаге работы системы? Каковы назначение и результат использования алгоритма унификации?}
На первом шаге работы системы унифицируется вопрос с первым термом в разделе \textbf{clauses}. Унификация~--- основной вычислительный шаг работы программы, предназначенный для формализации процесса логического вывода. Унификация – попытка сопоставить два терма. Результатом алгоритма унификации является <<успех>> или <<неудача>>. В случае удачи в результатом также является наиболее общий унификатор двух унифицируемых термов.

\section{В каком случае запускается механизм отката?}
Откат дает возможность получить много решений в одном вопросе к программе. Во всех точках программы, где существуют альтернативы, в стек заносятся точки возврата.

Если впоследствии окажется, что выбранный вариант не приводит к успеху, то осуществляется откат к последней из имеющихся в стеке точек программы, где был выбран один из альтернативных вариантов.

Выбирается очередной вариант, программа продолжает свою работу. Если все варианты в точке уже были использованы, то регистрируется неудачное завершение и осуществляется переход на предыдущую точку возврата, если такая есть. При откате все связанные переменные, которые были означены после этой точки, опять освобождаются.

